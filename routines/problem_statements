Goroutines
    A goroutine is a lightweight thread managed by the Go runtime.
        go f(x, y, z)
    starts a new goroutine running
        f(x, y, z)
    Note: The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens
    in the new goroutine.
    Goroutines run in the same address space, so access to shared memory must be synchronized.
    The sync package provides useful primitives, although you won't need them much in Go as there are other primitives.

Channels
    Channels are a typed conduit through which you can send and receive values with the channel operator, <-.
        ch <- v     // Send v to channel ch.
        v := <-ch   // Receive from ch, and
                    // assign value to v.
    (The data flows in the direction of the arrow.)

    Like maps and slices, channels must be created before use:
    ch := make(chan int)
    By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without
    explicit locks or condition variables.
    problem_01
    The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines
    have completed their computation, it calculates the final result.

Buffered Channels
    Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:
        ch := make(chan int, 100)
    Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.

Range and Close
    A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has
    been closed by assigning a second parameter to the receive expression: after
        v, ok := <-ch
    ok is false if there are no more values to receive and the channel is closed.
    The loop for i := range c receives values from the channel repeatedly until it is closed.

    Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.
    Note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver
    must be told there are no more values coming, such as to terminate a range loop.

Select
    The select statement lets a goroutine wait on multiple communication operations.
    A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple
    are ready.

Default Selection
    The default case in a select is run if no other case is ready.
    Use a default case to try a send or receive without blocking:
    select {
        case i := <-c:
            // use i
        default:
            // receiving from c would block
    }

Exercise: Equivalent Binary Trees
    1. Implement the Walk function.
    2. Test the Walk function.
        The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values
        k, 2k, 3k, ..., 10k.
        Create a new channel ch and kick off the walker:
            go Walk(tree.New(1), ch)
        Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.
    3. Implement the Same function using Walk to determine whether t1 and t2 store the same values.
    4. Test the Same function.
    Same(tree.New(1), tree.New(1)) should return true, and Same(tree.New(1), tree.New(2)) should return false.
    The documentation for Tree can be found https://godoc.org/golang.org/x/tour/tree#Tree.